pipelines {
  read -> cross;
  read2 -> cross;
  cross -> cross2;
  read3 -> cross2;
  read4 -> cross3;
  read5 -> cross3;
  cross3 -> cross4;
  read6 -> cross4;
  cross2 -> filter -> project -> aggregate -> project2;
  cross4 -> filter2 -> project3 -> aggregate2 -> filter3 -> sort -> root;
}

read relation read {
  source named;
  base_schema schema;
}

read relation read2 {
  source named2;
  base_schema schema2;
}

cross relation cross {
}

read relation read3 {
  source named3;
  base_schema schema3;
}

cross relation cross2 {
}

filter relation filter {
  filter and(
    equal(schema.PS_SUPPKEY, schema2.S_SUPPKEY)->bool, 
    equal(schema2.S_NATIONKEY, schema3.N_NATIONKEY)->bool, 
    equal(schema3.N_NAME, "JAPAN"_fixedchar<5> AS fixedchar<25>)->bool?)->bool?;
}

project relation project {
  expression multiply(schema.PS_SUPPLYCOST, schema.PS_AVAILQTY AS decimal?<19,0>)->decimal?<19,0> NAMED intermediate;

  emit intermediate;
}

aggregate relation aggregate {
  measure {
    measure sum(intermediate)->decimal?<19,0>@AGGREGATION_PHASE_INITIAL_TO_RESULT NAMED measurename;
    invocation all;
  }
}

project relation project2 {
  expression multiply(measurename, 1000000_decimal<11,10>)->decimal?<19,10> NAMED intermediate2;

  emit intermediate2;
}

read relation read4 {
  source named4;
  base_schema schema4;
}

read relation read5 {
  source named5;
  base_schema schema5;
}

cross relation cross3 {
}

read relation read6 {
  source named6;
  base_schema schema6;
}

cross relation cross4 {
}

filter relation filter2 {
  filter and(
    equal(schema4.PS_SUPPKEY, schema5.S_SUPPKEY)->bool, 
    equal(schema5.S_NATIONKEY, schema6.N_NATIONKEY)->bool, 
    equal(schema6.N_NAME, "JAPAN"_fixedchar<5> AS fixedchar<25>)->bool?)->bool?;
}

project relation project3 {
  expression schema4.PS_PARTKEY;
  expression multiply(schema4.PS_SUPPLYCOST, schema4.PS_AVAILQTY AS decimal?<19,0>)->decimal?<19,0> NAMED intermediate3;

  emit schema4.PS_PARTKEY;
  emit intermediate3;
}

aggregate relation aggregate2 {
  grouping schema4.PS_PARTKEY;
  measure {
    measure sum(intermediate3)->decimal?<19,0>@AGGREGATION_PHASE_INITIAL_TO_RESULT NAMED measurename2;
    invocation all;
  }
}

filter relation filter3 {
  filter gt(measurename2, SUBQUERY project2)->bool?;
}

sort relation sort {
  sort measurename2 by DESC_NULLS_FIRST;
}

root {
  names = [
    PS_PARTKEY,
    value
  ]
}

schema schema {
  PS_PARTKEY i64;
  PS_SUPPKEY i64;
  PS_AVAILQTY i32?;
  PS_SUPPLYCOST decimal?<19,0>;
  PS_COMMENT varchar?<199>;
}

schema schema2 {
  S_SUPPKEY i64;
  S_NAME fixedchar?<25>;
  S_ADDRESS varchar?<40>;
  S_NATIONKEY i64;
  S_PHONE fixedchar?<15>;
  S_ACCTBAL decimal?<19,0>;
  S_COMMENT varchar?<101>;
}

schema schema3 {
  N_NATIONKEY i64;
  N_NAME fixedchar?<25>;
  N_REGIONKEY i64;
  N_COMMENT varchar?<152>;
}

schema schema4 {
  PS_PARTKEY i64;
  PS_SUPPKEY i64;
  PS_AVAILQTY i32?;
  PS_SUPPLYCOST decimal?<19,0>;
  PS_COMMENT varchar?<199>;
}

schema schema5 {
  S_SUPPKEY i64;
  S_NAME fixedchar?<25>;
  S_ADDRESS varchar?<40>;
  S_NATIONKEY i64;
  S_PHONE fixedchar?<15>;
  S_ACCTBAL decimal?<19,0>;
  S_COMMENT varchar?<101>;
}

schema schema6 {
  N_NATIONKEY i64;
  N_NAME fixedchar?<25>;
  N_REGIONKEY i64;
  N_COMMENT varchar?<152>;
}

source named_table named {
  names = [
    "PARTSUPP",
  ]
}

source named_table named2 {
  names = [
    "SUPPLIER",
  ]
}

source named_table named3 {
  names = [
    "NATION",
  ]
}

source named_table named4 {
  names = [
    "PARTSUPP",
  ]
}

source named_table named5 {
  names = [
    "SUPPLIER",
  ]
}

source named_table named6 {
  names = [
    "NATION",
  ]
}

extension_space /functions_arithmetic_decimal.yaml {
  function multiply:dec_dec as multiply;
  function sum:dec as sum;
}

extension_space /functions_boolean.yaml {
  function and:bool as and;
}

extension_space /functions_comparison.yaml {
  function equal:any_any as equal;
  function gt:any_any as gt;
}
